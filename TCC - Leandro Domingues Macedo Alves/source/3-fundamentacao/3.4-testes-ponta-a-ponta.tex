\hypertarget{testes-ponta-a-ponta}{%
\section{\texorpdfstring{Testes ponta a ponta}{Testes ponta a ponta}}\label{testes-ponta-a-ponta}}

Testes de unidade conseguem avaliar isoladamente diversos módulos e testes de integração são capazes de avaliar a interação entre estes módulos. Entretanto, levando em consideração o cenário de aplicação web, com diversos navegadores usando diferentes extensões e em diferentes sistemas operacionais, as verificações apenas de módulos e suas integrações são insuficientes para garantir a compatibilidade em múltiplos ambientes. É necessário também reproduzir uma verificação que seja a mais fiel possível à experiência do usuário. Isso significa a necessidade de testar a interação com o sistema, a partir de sua interface gráfica, e a integração do sistema, desde a requisição das informações no banco de dados até ser corretamente disponibilizada ao usuário. Todos os setores se comportando da forma esperada de acordo com as ações do usuário na interface. A forma de verificação automatizada mais próxima de atender esse desafio é a realização de testes \emph{end-to-end}, também chamados de testes ponta a ponta, testes de interface do usuário, \emph{chain testing} ou coloquialmente testes \emph{e2e}.

Em uma análise histórica, no fim da década de 80 ocorreu o surgimento dos \emph{event-driven GUI software}, que nada mais eram do que programas que possuíam o funcionamento determinado pelos eventos acionados pelo usuário, como cliques e teclas. Com estes novos programas, novas ferramentas de testes também foram desenvolvidas, como \emph{Segue} e \emph{Mercury}. Essas ferramentas eram baseadas na metodologia do \emph{capture and replay} na qual os testes manuais dos usuários eram inicialmente gravados e depois repetidos automaticamente como forma de teste de regressão.

A metodologia de testes de interface se manteve estacionária até 2004, quando Jason Huggins desenvolveu a ferramenta \emph{Selenium} para teste de aplicações web \cite{brown}.\emph{Selenium} é um \emph{framework} de testes disponível em diversas linguagens, que reproduz uma série de comandos diretamente no navegador, na tentativa de reproduzir o comportamento humano. Diferentemente do método de \emph{capture and replay}, o \emph{Selenium} permite que as instruções de comandos sejam feitas diretamente no código, tornando mais fácil sua manutenção e escalabilidade. A partir disso novas ferramentas passaram a existir, popularizando o desenvolvimento de testes \emph{e2e}.

O objetivo dos testes de \emph{e2e} é assegurar que todas as partes integradas de uma aplicação funcionem como esperado, a partir de simulações de como um usuário real usaria a aplicação. Tais simulações têm que ser feitas contendo o maior número possível de diferentes ambientes em que será utilizada a aplicação, validando na perspectiva do usuário final. Para a realização desses testes, é fundamental o conhecimento da aplicação como um todo.

Durante o teste \emph{e2e}, os diferentes componentes da sua aplicação são avaliados de forma unificada, de forma que banco de dados, \emph{back-end} e \emph{front-end} sejam avaliados simultaneamente. Enquanto os testes de unidade e de integração identificam inconsistências de forma mais modular e a nível de código, os testes de \emph{e2e} procuram por inconsistências em um panorama geral. De certa forma, pode-se dizer que testes \emph{e2e} possuem um alcance maior do que testes de unidade e de integração, mas ao mesmo tempo não possuem a mesma precisão e objetividade em identificar a localização de um erro, consequentemente sendo menos simples o processo de depuração de erros.

Na literatura mais atual, pode-se encontrar em alguns casos em que testes \emph{e2e} não são considerados testes de sistema \cite{chowdhury}. Isso se deve ao fato de ainda haver discordância na comunidade sobre a área de atuação de testes de sistemas. Para alguns, os testes \emph{e2e} são realizados posteriormente aos testes de sistema, fazendo verificações adicionais não funcionais que não são responsabilidade dos testes de sistema. Entretanto, baseando-se em Myers \emph{et al.} \cite{myers} e o conceito de que o objetivo dos testes de sistema é, acima de tudo, apresentar que o produto está de acordo com seus objetivos iniciais, pode-se concluir que testes \emph{e2e} possuem características de teste de sistema, já que esse é seu principal objetivo, apesar de verificar por consequência também critérios não funcionais.

O desenvolvimento de testes de \emph{e2e} requer inicialmente a análise dos requisitos feitos pelos usuários, que pode ser especificado em um plano de testes. A partir daí são definidas \emph{personas} que são identidades para caracterizar um grupo de usuários de acordo com suas características comuns, como permissões de acesso, ambiente de navegação e acessibilidade. Obtendo estes agrupamentos, condições são implementadas baseando-se em cada \emph{persona}, que se transformam no fim em diferentes casos de testes. Estes casos de testes contêm informações sobre as ações permitidas aos usuários, que são então convertidas em comandos escritos em código. Esses comandos são então executados e passam a representar o usuário, realizando ações na interface como cliques de botões, escritas de texto e navegação de links.

Com o desenvolvimento de testes automáticos para sua aplicação, uma outra necessidade passa a surgir, que é como gerenciá-los. Se torna preciso a existência de um agente controlador que execute os testes com uma certa frequência ou à medida que ocorre uma atualização na aplicação, reportando os possíveis erros de regressão encontrados. A integração contínua é vista como uma opção para isso, e será discutido em mais detalhes na próxima seção.
