\hypertarget{testes-unitarios}{%
\section{Testes unitários}\label{testes-unitarios}}

É fundamental para as soluções automatizadas que sejam flexíveis tanto para mudanças grandes de código, quanto para pequenas, como uma alteração mínima de função. As verificações têm que ser independentes entre si e terem a capacidade de testar aquilo que foi mudado, sem a interferência de fatores externos. Uma das soluções que vieram para tentar remediar estas dificuldades, e que vem sendo aplicadas cada vez mais nos softwares, é a adoção de testes unitários. Segundo o estudo feito por Yuan \cite{yuan}, "a maioria dos incidentes em ambiente de produção (77\%) podem ser reproduzidos por um teste unitário".

Desde 1976 , é possível ver o início do desenvolvimento de ferramentas com propósitos semelhantes ao dos testes unitários atuais \cite{panzl}. Testes eram separados em dois tipos: verificação e validação. Testes de verificação eram referentes a exatidão lógica do programa e funcionamento correto de acordo com as especificações, enquanto testes de validação eram voltados a performance e a eficiência do programa de acordo com o ambiente de usuário.

Testes de verificação eram pouco enfatizados durante o processo de desenvolvimento de software. Nenhuma metodologia era utilizada e as verificações na maior parte dos casos eram por meio de depuração manual apenas, ou seja, \emph{debugging}. Dessa forma, Panzl e seu time da General Electric propuseram a \emph{Test Procedure Language} para a linguagem \emph{Fortran}, que se tratava de uma extensão para desenvolver testes que fossem completos, compactos e auto contidos. Definição que hoje em dia se assemelha com a de testes unitários.

Em 1989 Kent Beck menciona o \emph{SUnit} em uma publicação, que se tratava e que ainda hoje é utilizado, de um \emph{framework} de testes unitários para a linguagem orientada a objetos \emph{SmallTalk} \cite{beck2}. Nesta publicação, Beck proporciona uma série de diretrizes, padrões de design e ferramentas para facilitar a desenvolvimento e organização de testes unitários no novo paradigma na época de orientação a objetos. A primeira versão de \emph{SUnit} foi desenvolvida em 1994 e sua publicação em 1999.

Em 1997 Kent Beck e Erich Gamma começaram a migrar a filosofia da \emph{SUnit} para a linguagem \emph{Java} com o desenvolvimento do \emph{JUnit}. A facilidade encontrada em realizar os testes unitários de forma rápida e eficiente fez com que a ferramenta se tornasse popular, e com isso ramificações passaram a existir também para outras linguagens, marcando o início do design \emph{xUnit}, que se trata da família de \emph{frameworks} de testes unitários, atualmente disponíveis para mais de 80 linguagens. Como exemplo, o trabalho desenvolvido na área de testes unitários foi realizado utilizando \emph{phpunit}, que se trata de um descendente do original \emph{SUnit}.

Conforme significado presente em Hamill \cite{hamill}, testes unitários, ou testes de unidade, são definidos como testes que implementam uma metodologia na qual trechos individuais de código são testados de forma automática. Uma unidade é definida como a menor parte possível de um software que pode ser testada de forma independente, ou seja, sem a necessidade de interações externas. Por exemplo em programação \emph{procedural}, uma unidade pode ser uma função ou módulo, enquanto em programação orientada a objetos uma unidade é frequentemente caracterizada como um método de visibilidade pública ou até mesmo uma classe.

Em geral o funcionamento de um teste unitário é bem simples. Inicialmente, o teste unitário recebe uma ou mais entradas, que são necessárias para o funcionamento da unidade a ser testada. A unidade é então executada e a sua saída é coletada, comparando-a com o valor de referência que era esperado com as entradas iniciais. Dessa forma é garantido o funcionamento da unidade para esse cenário.

Dada a importância atual dos testes unitários no processo de desenvolvimento de software, hoje em dia a maior parte das linguagens possuem bibliotecas desenvolvidas para auxílio no desenvolvimento de testes unitários. Testes unitários são os primeiros dos testes a serem executados e onde se detectam a maior parte dos erros de programação. Eles examinam o software a nível modular ou unitário, checando os métodos, fórmulas, caminhos lógicos e pontos de decisão encontrados no código, podendo ser executados pelo próprio desenvolvedor ao alterar o código.

A mérito qualitativo, à medida que novas linhas são escritas, ferramentas adicionais podem ser utilizadas para avaliar o quanto do código está sendo coberto e garantido por testes unitários. Pela literatura, tal verificação é chamada de cobertura de código, e levantamentos como o feito por Yang \cite{yang} mostram as diversas ferramentas disponíveis.

Testes de unidade também trazem benefícios em relação a documentação e ao próprio \emph{design} de código. Desenvolvedores passam a entender melhor o comportamento de um módulo a partir da saída esperada e da entrada proporcionada pelo teste unitário. Além disso, para um desenvolvimento mais simplificado de um teste unitário em seu isolamento, o programador deve estar atento a qualidade de seu código, como por exemplo evitar a implantação de chamadas externas diretas que inviabilizam a implementação de \emph{mocks}.
