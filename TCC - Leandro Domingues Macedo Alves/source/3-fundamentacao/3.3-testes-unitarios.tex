\hypertarget{testes-unitarios}{%
\section{Testes unitários}\label{testes-unitarios}}

É fundamental que as soluções automatizadas sejam flexíveis tanto para mudanças grandes de código, quanto para pequenas, como uma alteração mínima dentro de uma função. As verificações têm que ser independentes entre si e terem a capacidade de testar aquilo que foi mudado, sem a interferência de fatores externos. Uma das soluções concebidas para atender este objetivo de modularidade, e que vem sendo cada vez mais aplicada em softwares, é a implementação de testes unitários. Segundo o estudo feito por Yuan \cite{yuan}, "a maioria dos incidentes em ambiente de produção (77\%) podem ser reproduzidos por um teste unitário".

Desde 1976, é possível ver o início do desenvolvimento de ferramentas com propósitos semelhantes a dos testes unitários atuais \cite{panzl}. Testes eram separados em dois tipos: verificação e validação. Testes de verificação eram referentes a exatidão lógica do programa e funcionamento correto de acordo com as especificações, enquanto testes de validação eram voltados a performance e a eficiência do programa de acordo com o ambiente de usuário.

Testes de verificação eram pouco enfatizados durante o processo de desenvolvimento de software. Nenhuma metodologia era utilizada e as verificações na maior parte dos casos eram por meio de depuração manual apenas, ou seja, \emph{debugging}. Dessa forma, Panzl e seu time da \emph{General Electric} propuseram a \emph{Test Procedure Language} para a linguagem \emph{Fortran}, que se tratava de uma extensão para desenvolver testes que fossem completos, compactos e auto contidos. Definição que hoje em dia se assemelha com a de testes unitários.

Em 1989 Kent Beck menciona o \emph{SUnit} em uma publicação, que se tratava e que ainda hoje é utilizado, de um \emph{framework} de testes unitários para a linguagem orientada a objetos \emph{SmallTalk} \cite{beck2}. Nesta publicação, Beck proporciona uma série de diretrizes, padrões de design e ferramentas para facilitar o desenvolvimento e organização de testes unitários no novo paradigma da época, que era a orientação a objetos. A primeira versão de \emph{SUnit} foi desenvolvida em 1994 e sua publicação em 1999.

Em 1997 Kent Beck e Erich Gamma começaram a migrar a filosofia da \emph{SUnit} para a linguagem \emph{Java} com o desenvolvimento do \emph{JUnit}. A facilidade encontrada em realizar os testes unitários de forma rápida e eficiente fez com que a ferramenta se tornasse popular, e com isso ramificações passaram a existir também para outras linguagens, marcando o início do design \emph{xUnit}, que se trata da família de \emph{frameworks} de testes unitários, atualmente disponíveis para mais de 80 linguagens. Como exemplo, o trabalho desenvolvido na área de testes unitários foi realizado utilizando \emph{phpunit}, que se trata de um descendente do original \emph{SUnit}.

Conforme significado presente em Hamill \cite{hamill}, testes unitários, ou testes de unidade, são definidos como testes que implementam uma metodologia na qual trechos individuais de código são testados de forma automática. Uma unidade é definida como a menor parte possível de um software que pode ser testada de forma independente, ou seja, sem a necessidade de interações externas. Por exemplo em programação \emph{procedural}, uma unidade pode ser uma função, enquanto em programação orientada a objetos uma unidade é frequentemente caracterizada como um método de visibilidade pública ou até mesmo uma classe.

Em geral o funcionamento de um teste unitário é bem simples. Inicialmente, o teste unitário recebe uma ou mais entradas que são necessárias para o funcionamento da unidade a ser testada. A unidade é então executada e a sua saída é coletada, comparando-a com o valor de referência que era esperado com as entradas iniciais. Desta forma é garantido o funcionamento da unidade testada para este caso.

Dada a importância atual dos testes unitários no processo de desenvolvimento de software, hoje em dia a maior parte das linguagens possuem bibliotecas desenvolvidas para auxílio no desenvolvimento destes testes. Testes unitários são os primeiros testes a serem executados, e onde se detectam a maior parte dos erros de programação. Eles examinam o software a nível modular ou unitário, checando os métodos, fórmulas, caminhos lógicos e pontos de decisão encontrados no código, podendo ser executados pelo próprio desenvolvedor ao alterar o código.

A mérito quantitativo, à medida que novas linhas são escritas, ferramentas adicionais podem ser utilizadas para avaliar o quanto do código está sendo coberto e garantido por testes unitários. Pela literatura, tal verificação é chamada de cobertura de código, e levantamentos como o feito por Yang \cite{yang} mostram a disponibilidade de diversas ferramentas que permitem analisar o alcance dos testes unitários na base de código.

Testes de unidade também trazem benefícios em relação à documentação e à própria arquitetura de código. Desenvolvedores passam a entender melhor o comportamento de um módulo a partir da entrada proporcionada e da saída esperada pelo teste unitário, servindo como documentação adicional. Além disso, para um desenvolvimento mais simplificado de um teste unitário, o programador deve estar atento a qualidade de seu código, como por exemplo evitar a utilização direta de métodos externos, pois inviabilizam a simulação de objetos.
