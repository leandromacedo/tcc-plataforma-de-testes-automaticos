\hypertarget{integracao-continua}{%
\section{Integração contínua}\label{integracao-continua}}

Conforme apresentado por Howard Deiner \cite{deiner}, tanto o desenvolvimento de software como o de seus testes automáticos são necessariamente realizados pelos programadores. Até o momento, não é possível o desenvolvimento de testes de unidade, de integração ou \emph{end-to-end} por mecanismos automáticos. Entretanto sua execução pode ser automatizada. Não é necessário que o programador seja responsável por realizar tarefas repetitivas como, preparar o ambiente de testes, executá-los e verificar os resultados de modo individual. Além de poder ser caracterizado como um desaproveitamento de recursos humanos, pode ser visto também como arriscado, já que erros podem ocorrer nos procedimentos a serem tomados ou nas observações dos resultados.

Uma solução automática de integração pode melhorar a produtividade do desenvolvedor, encontrar inconsistências de forma mais eficiente e distribuir novas versões da aplicação mais rapidamente.

Fowler \emph{et al.} \cite{fowler} define integração contínua como uma prática de desenvolvimento de software na qual membros de uma equipe integram seus desenvolvimentos frequentemente, podendo ocorrer diversas vezes ao dia. Cada integração é verificada por um processo automático de compilação e teste, detectando erros mais rapidamente. Isso por fim agiliza o desenvolvimento e o torna mais coeso, indo de acordo com os princípios do desenvolvimento ágil. Integração contínua também é conhecido como \emph{continuous integration} ou apenas \emph{CI}.

Como apresentado por Fowler e detalhado em Shanin \emph{et al.} \cite{shahin}, a integração contínua é aplicada juntamente a uma plataforma de controle de versão, como a ferramenta \emph{Git}. Assim que um pedido de novo código é submetido à base de código, por meio de um processo denominado de \emph{merge request}, a integração contínua entra em ação antes deste código ser adicionado. Ao identificar essa requisição, a integração contínua executa uma canalização, mais conhecido como \emph{pipeline}, que consiste em uma cadeia de tarefas a serem realizadas, chamadas \emph{jobs}. Cada \emph{job} fica responsável por uma ação específica, como compilação, testes de unidades, ou testes \emph{e2e}, e se em algum momento algum dos \emph{jobs} falha, o \emph{pipeline} é imediatamente interrompido, informando os autores da requisição e impedindo a adição do código.

Juntamente com a integração contínua, pode ocorrer uma prática complementar semelhante que é a distribuição contínua, ou \emph{continuous delivery}. Após o processo de integração ter sido realizado com sucesso, a distribuição contínua se responsabiliza pelo \emph{deploy}, ou seja, distribuir todas as alterações de código em um ambiente de teste ou ambiente de produção, realizando todas as etapas necessárias também de forma automatizada.

Para o funcionamento da integração contínua é fundamental a existência de um ambiente para execução das tarefas. Isso significa, na condição mais simples, a existência de um servidor que esteja devidamente configurado para realizar as tarefas da integração contínua. Para tarefas simples que exigem pouco processamento, como compilação da aplicação e testes unitários, apenas uma máquina pode ser suficiente para desempenhar tais obrigações. Entretanto, em certos casos como o deste trabalho, há tarefas mais complexas, como os testes \emph{e2e}, que exigem a necessidade de um processamento maior que apenas uma instancia operacional
pode oferecer.

Os testes \emph{e2e} reproduzem o usuário utilizando o navegador web, realizando as ações humanas com tempo de duração semelhante. Por conta disso, se todos estes testes forem postos em série, o \emph{job} de integração contínua pode demorar para ser concluído, inviabilizando o processo em ambientes que empregam metodologia ágil. Portanto é necessário o ato de paralelizar os testes \emph{e2e}, tornando a execução mais rápida, e para isso um \emph{cluster} de máquinas se torna uma solução viável. Para o correto funcionamento concomitante de cada máquina do \emph{cluster}, uma comunicação entre elas é essencial, e a partir daí vem o conceito de sistemas distribuídos.

Segundo Tanenbaum \emph{et al.} \cite{tanenbaum}, um sistema distribuído é "uma coleção de computadores independentes que aparenta aos seus utilizadores como um sistema único e coerente". É importante a independência entre as máquinas para garantir a fácil escalabilidade quando necessário, mas ao mesmo tempo abstraindo a complexidade interna para tornar simples sua utilização, no caso pela integração contínua. Nestes computadores, uma camada de software adicional é implementada, entre a camada do sistema operacional e a das aplicações em que serão executadas as tarefas, como os testes \emph{e2e}. Essa camada possibilita a comunicação entre as aplicações e simplifica as possíveis diferenças de hardware e sistema operacional de cada instancia.

Uma forma de estruturar os testes \emph{e2e} em um ambiente de sistemas distribuídos é por meio de uma divisão entre primário e secundário, como presente em Nwana \emph{et al.} \cite{nwana}. As máquinas primárias são as responsáveis por atender o pedido do utilizador e gerenciar a execução dos testes para as máquinas secundárias. As máquinas primárias coletam os resultados de cada máquina secundária e enviam o resultado final para a integração contínua.

No próximo capítulo será apresentado o trabalho desenvolvido com base na fundamentação, com a reestruturação do grupo adotando práticas ágeis, desenvolvimento dos \emph{frameworks} de testes automáticos e a implementação de uma solução de integração e entrega contínua de software.
